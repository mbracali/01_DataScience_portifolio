---
title: "AnaliseVinhos"
author: "Marcelo Bracali"
date: "31/07/2019"
output:
  html_document: 
    fig_caption: yes
    fig_width: 14
    fig_height: 12
    highlight: haddock
    keep_md: yes
    number_sections: yes
    theme: simplex
    toc: yes
    df_print: paged
editor_options: 
  chunk_output_type: console
---

<style>
body {
      text-align: justify;  
      font-size: 14px;
    }
blockquote {
      font-size: 12px;
    }
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, knitr.table.format = "html")
```

```{r echo=FALSE, message=FALSE, warning=FALSE, packages}
## Instalando os pacotes requeridos
list.of.packages <- c("cowplot", "dplyr", "gridExtra", "GGally", "devtools", "digest", "rmarkdown", "knitr", "kableExtra", "stringi", "summarytools", "ggplot2", "corrplot", "cluster", "corrgram", "tclust", "fpc")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if (length(new.packages)) {
  install.packages(new.packages, dependencies = T)
}
## Carregando os pacotes
for (package_name in list.of.packages)
{library(package_name, character.only = TRUE, quietly = TRUE);}
```


# INFORMAÇÕES SOBRE O DATASET
```{r echo = FALSE, Load_the_Data}
# Carregando os dados do arquivo
# filename <- file.choose()
filename <- "C:/Users/angelo.a.borges/Downloads/BaseWine_Red_e_White.csv"
vinhos <- read.csv2(filename, skip = 0, sep = ';')
name <- basename(filename)
```
O dataset multipropriedade, fornecido para análise compreende duas amostras de vinhos (Brancos e Tintos), do vinho "Vinho Verde" do norte de Portugal, e suas propriedades quimicas e físicas. Esse dataset foi doado em 7 de outubro de 2009.

Por questões de privacidade e logística, apenas as variáveis físico-químicas (insumos) e sensoriais (a saída) estão disponíveis (por exemplo, não há dados sobre tipos de uva, marca de vinho, preço de venda do vinho, etc.).

Fonte: Paulo Cortez, University of Minho, Guimarães, Portugal, http://www3.dsi.uminho.pt/pcortez 
A. Cerdeira, F. Almeida, T. Matos and J. Reis, Viticulture Commission of the Vinho Verde Region(CVRVV), Porto, Portugal @2009.

## Características do dataset "vinhos"

O dataset, aqui nomeado de 'vinhos', onde foi carregada a base de dados fornecida, possui as seguintes características:

```{r, echo = FALSE}
## Caso desejemos excluir alguma das propriedades pode-se utilizar o comando comentado abaixo
# vinhos$nomepropriedade = NULL
cn <- ncol(vinhos)
rn <- nrow(vinhos)
cat(paste0(cn, " colunas e ", rn," linhas."))
vprops <- paste(names(vinhos), collapse = ", ")
cat(paste0("Sendo suas propriedades: ", vprops))
```

Analisando as propriedades do dataset, percebemos a necessidade de qualificar de forma discreta os vinhos pelos seu fatores de qualidade. Dessa forma, criamos algumas categorias conforme descrito abaixo:

```{r, echo = TRUE, code_folding: show}
#vinhos$quality.factor <- factor(vinhos$quality)
vinhos$quality.cat <- NA
vinhos$quality.cat <- ifelse(as.numeric(as.character(vinhos$quality)) >= 7, 'good', NA)
vinhos$quality.cat <- ifelse(as.numeric(as.character(vinhos$quality)) == 6, 'medium', vinhos$quality.cat)
vinhos$quality.cat <- ifelse(as.numeric(as.character(vinhos$quality)) == 5, 'medium', vinhos$quality.cat)
vinhos$quality.cat <- ifelse(as.numeric(as.character(vinhos$quality)) <= 4, 'bad', vinhos$quality.cat)
vinhos$quality.cat <- factor(vinhos$quality.cat, levels = c("bad", "medium", "good"))
```

```{r, echo = F}
#Também criamos uma nova propriedade númerica para os tipos dos vinhos:
#vinhos$type <- NA
#vinhos$type <- ifelse(as.character(vinhos$Vinho) == 'WHITE', 1L, ifelse(as.character(vinhos$Vinho) == 'RED', 2L, NA))
```

Como pode ser analizado, todos os atributos são numéricos, exceto o atributo 'quality', que 
é fatorizado.

Também entendemos que as propriedades "fixedacidity", "volatileacidity" e "citricacid" compoem a acidez total do vinho. Dessa forma, geramos uma nova propriedade chamada "totalacidity" para sumariza-las.

```{r, echo = TRUE}
vinhos$totalacidity <- with(vinhos, fixedacidity + volatileacidity + citricacid)
```

Para compararmos os dois tipos de vinhos, criaremos dois vetores, aqui denominados vinhosBrancos e vinhosTintos. 

```{r, echo = TRUE}
vinhos %>% filter(vinhos$Vinho == "WHITE") -> vinhosBrancos
vinhos %>% filter(vinhos$Vinho == "RED") -> vinhosTintos
```

Após criarmos esses dois novos vetores, obtivemos:
```{r, echo = FALSE}
cn.V <- ncol(vinhos)
rn.VB <- nrow(vinhosBrancos)
rn.VT <- nrow(vinhosTintos)

cat(paste0("Quantidade de propriedades: ", cn.V))
vprops <- paste(names(vinhos), collapse = ", ")
cat(paste0("Sendo suas propriedades: ", vprops))

cat(paste0("Quantidade de linhas para Vinhos Brancos: ", rn.VB))
cat(paste0("Quantidade de linhas para Vinhos Tintos: ", rn.VT))
```

## Identificação das propriedades dos dois tipos de vinhos
```{r, echo = FALSE}
library(stringi)
defChunkHook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- defChunkHook(x, options)
  if (!is.null(options$multi.col)) {
    x    <- gsub("(\n\`\`\`\n##.*?\`\`\`)", "<div>\\1\n</div>", x)  # wrap div around output chunks
    x    <- gsub("(<img.*?>)", "<div>\\1\n</div>", x)               # wrap div around plots
    ncol <- nrow(stri_locate_all(x, regex = "<div.*?>")[[1]])       # get the number of div elements created
    x    <- gsub("<div>", paste0("<div style=\"width:", 100/ncol,"%;\">"), x)  # add the width to the divs
    x    <- paste0("<div class=\"multi-col\" style=\"display: flex; justify-content: center; align-items: center;\">\n", x, "</div>")  # wrap the mother div around all of the output
  }
  x
})

create_histogram = function(dat_set, variabl, binwidth = 0.25) {
  return( ggplot(aes_string(x = variabl), data = dat_set) + 
            geom_histogram(bins = 35, binwidth = binwidth,
                           color = 'black', fill = '#F79420') )
}


vinhosBrancos.semOutliers = vinhosBrancos
vinhosTintos.semOutliers = vinhosTintos
```

### Identificador do vinho - [1] "id_vinho":

### Acidez Fixa (g/dm^3) - [2] "fixedacidity":
a maioria dos ácidos presentes no vinho ou fixos ou não voláteis (não evaporaram prontamente)

Os ácidos são os principais constituintes do vinho e contribuem grandemente para o seu sabor. De fato, os ácidos transmitem a acidez que é uma característica fundamental no gosto do vinho. Vinhos sem ácido são "planos". Quimicamente, os ácidos influenciam a acidez titulável que afeta o sabor e o pH, o que afeta a cor, a estabilidade à oxidação e, consequentemente, a vida útil de um vinho. Os mais abundantes destes ácidos surgem nas próprias uvas e são transportados para o vinho. 

Tradicionalmente, a acidez total é dividida em dois grupos, a saber, os ácidos voláteis (ver descrição em separado) e os ácidos não voláteis ou fixos.

Os ácidos fixos predominantes encontrados nos vinhos são tartárico, málico, cítrico e succínico. Seus respectivos níveis encontrados no vinho podem variar muito, mas em geral se esperaria ver 1.000 a 4.000 mg / L de ácido tartárico, 0 a 8.000 mg / L de ácido málico, 0 a 500 mg / L de ácido cítrico e 500 a 2.000 mg / l L ácido succínico. Todos esses ácidos são originários de uvas, com exceção do ácido succínico, que é produzido pela levedura durante o processo de fermentação. As uvas também contêm ácido ascórbico (vitamina C), mas isso é perdido durante a fermentação. Também é legal adicionar o ácido fumárico como conservante.

Os vinhos produzidos a partir de uvas de clima fresco são ricos em acidez e, portanto, têm sabor azedo. Estes vinhos de alta acidez podem ser tratados para reduzir a acidez, seja por agentes neutralizantes, seja por fermentação maloláctica. As uvas de clima quente podem ser baixas em ácido, mais ou menos dependendo da variedade. Nestas áreas é adicionado ácido tartárico, reciclado a partir de vinificação, para aumentar a acidez e evitar que os vinhos sejam planos. Atualmente, os produtores de vinho da Califórnia estão levando os vinhos a níveis elevados de pH, chegando a 4,0, enquanto 20 anos atrás, o pH acima de 3,6 era incomum. Isso torna os vinhos mais suaves, populares entre os escritores de vinhos de hoje.

Fonte: https://waterhouse.ucdavis.edu/whats-in-wine/fixed-acidity

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"fixedacidity"])
summarytools::descr(vinhosTintos.semOutliers[,"fixedacidity"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
#vb.fixedacidity.boxplot = create_boxplot(vinhosBrancos, 'fixedacidity') 
vb.fixedacidity.boxplot = qplot(x = 1, y = vinhosBrancos.semOutliers$fixedacidity, 
                                data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + 
          coord_flip() + ylim(min(vinhosBrancos.semOutliers$fixedacidity),max(vinhosBrancos.semOutliers$fixedacidity))

# vt.fixedacidity.boxplot = create_boxplot(vinhosTintos, 'fixedacidity') +
vt.fixedacidity.boxplot = qplot(x = 1, y = vinhosTintos.semOutliers$fixedacidity, 
                                data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + 
          coord_flip() + ylim(min(vinhosTintos.semOutliers$fixedacidity),max(vinhosTintos.semOutliers$fixedacidity))

vb.fixedacidity.hist = create_histogram(vinhosBrancos.semOutliers, 'fixedacidity')
vt.fixedacidity.hist = create_histogram(vinhosTintos.semOutliers, 'fixedacidity')

#Mostrando o resultado
plot_grid(vb.fixedacidity.boxplot, vt.fixedacidity.boxplot, vb.fixedacidity.hist, vt.fixedacidity.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Vemos aqui que os dados da propriedade fixedacidity (Acidez Fixa) são normalmente distribuídos.

### Acidez Voláil (g/dm^3) - [3] "volatileacidity":
a quantidade de ácido acético no vinho, que em níveis muito altos pode levar a um gosto desagradável de vinagre.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"volatileacidity"])
summarytools::descr(vinhosTintos.semOutliers[,"volatileacidity"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.volatileacidity.boxplot = qplot(x = 1, y = volatileacidity, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$volatileacidity),max(vinhosBrancos.semOutliers$volatileacidity))

vt.volatileacidity.boxplot = qplot(x = 1, y = volatileacidity, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$volatileacidity),max(vinhosTintos.semOutliers$volatileacidity))

vb.volatileacidity.hist = create_histogram(vinhosBrancos.semOutliers, 'volatileacidity', 0.05)
vt.volatileacidity.hist = create_histogram(vinhosTintos.semOutliers, 'volatileacidity', 0.05)

#Mostrando o resultado
plot_grid(vb.volatileacidity.boxplot, vt.volatileacidity.boxplot, vb.volatileacidity.hist, vt.volatileacidity.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Vemos aqui que os dados da propriedade volatileacidity (Acidez Volátil) são normalmente distribuídos.

### Ácido Cítrico (g/dm^3) - [4] "citricacid":
encontrado em pequenas quantidades, o ácido cítrico pode adicionar “frescura” e sabor aos vinhos.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"citricacid"])
summarytools::descr(vinhosTintos.semOutliers[,"citricacid"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.citricacid.boxplot = qplot(x = 1, y = citricacid, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$citricacid),max(vinhosBrancos.semOutliers$citricacid))

vt.citricacid.boxplot = qplot(x = 1, y = citricacid, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$citricacid),max(vinhosTintos.semOutliers$citricacid))

vb.citricacid.hist = create_histogram(vinhosBrancos.semOutliers, 'citricacid', 0.05)
vt.citricacid.hist = create_histogram(vinhosTintos.semOutliers, 'citricacid', 0.05)

#Mostrando o resultado
plot_grid(vb.citricacid.boxplot, vt.citricacid.boxplot, vb.citricacid.hist, vt.citricacid.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Vemos aqui que os dados da propriedade citricacid (Acido Cítrico) são normalmente distribuídos.

### Açúcar Residual (g/dm^3) - [5] "residualsugar":
a quantidade de açúcar restante depois que o processo de fermentação (em contato com a levedura, o açúcar da uva vai se transformando em álcool, ou seja, a fermentação vai ocorrendo)

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos[,"residualsugar"])
summarytools::descr(vinhosTintos[,"residualsugar"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.residualsugar.boxplot = qplot(x = 1, y = residualsugar, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$residualsugar),max(vinhosBrancos.semOutliers$residualsugar))

vt.residualsugar.boxplot = qplot(x = 1, y = residualsugar, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$residualsugar),max(vinhosTintos.semOutliers$residualsugar))

vb.residualsugar.hist = create_histogram(vinhosBrancos.semOutliers, 'residualsugar', 1)
vt.residualsugar.hist = create_histogram(vinhosTintos.semOutliers, 'residualsugar', 0.5)

#Mostrando o resultado
plot_grid(vb.residualsugar.boxplot, vt.residualsugar.boxplot, vb.residualsugar.hist, vt.residualsugar.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Vemos aqui que os dados da propriedade residualsugar (Açúcar Residual) são inclinados para a esquerda.

Ao comparar-mos o valor máximo de açucar residual com o terceiro quartil, há um enorme diferencial que pode ser observável. Isto é provavelmente devido a outliers. 

Dessa forma, iremos remover alguns outliers nos dois tipos de vinhos conforme abaixo:
```{r, echo = TRUE}

vinhosBrancos.semOutliers = vinhosBrancos[vinhosBrancos.semOutliers$residualsugar < 30, ]
vinhosTintos.semOutliers = vinhosTintos[vinhosTintos$residualsugar < 10, ]
```

Os gráficos abaixo foram gerados sem os outliers:

```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vbSemOutliers.residualsugar.boxplot = qplot(x = 1, y = residualsugar, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$residualsugar),max(vinhosBrancos.semOutliers$residualsugar))

vtSemOutliers.residualsugar.boxplot = qplot(x = 1, y = residualsugar, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$residualsugar),max(vinhosTintos.semOutliers$residualsugar))

vbSemOutliers.residualsugar.hist = create_histogram(vinhosBrancos.semOutliers, 'residualsugar', 1)
vtSemOutliers.residualsugar.hist = create_histogram(vinhosTintos.semOutliers, 'residualsugar', 0.2)

#Mostrando o resultado
plot_grid(vbSemOutliers.residualsugar.boxplot, vtSemOutliers.residualsugar.boxplot, vbSemOutliers.residualsugar.hist, vtSemOutliers.residualsugar.hist, labels = c("VB", "VT"), align = "v",ncol = 2)

```

E exibir novamente as estatisticas sobre eles, permitindo observar que a remoção dos outliers nos da uma visualização muito melhor sobre a distribuição dos dados.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"residualsugar"])
summarytools::descr(vinhosTintos.semOutliers[,"residualsugar"])
```

### Cloretos (g/dm^3) - [6] "chlorides": 
a quantidade de sal no vinho.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"chlorides"])
summarytools::descr(vinhosTintos.semOutliers[,"chlorides"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.chlorides.boxplot = qplot(x = 1, y = chlorides, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$chlorides),max(vinhosBrancos.semOutliers$chlorides))

vt.chlorides.boxplot = qplot(x = 1, y = chlorides, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$chlorides),max(vinhosTintos.semOutliers$chlorides))

vb.chlorides.hist = create_histogram(vinhosBrancos.semOutliers, 'chlorides', 0.007)
vt.chlorides.hist = create_histogram(vinhosTintos.semOutliers, 'chlorides', 0.009)

#Mostrando o resultado
plot_grid(vb.chlorides.boxplot, vt.chlorides.boxplot, vb.chlorides.hist, vt.chlorides.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Os dados na propriedade chlorides (Cloretos) são normalmente distribuídos. Os valores extremos de cloretos são difíceis de determinar sem maiores informações.

### Livre de  Dióxido de Enxofre (g/dm^3) - [7] "freesulfurdioxide":
a forma livre de SO2 existe em equilíbrio entre o SO2 molecular (como gás dissolvido) e o íon bissulfito; impede o crescimento microbiano e a oxidação do vinho. Garante condições melhores para os processos de vinificação da bebida, elimina bactérias e leveduras frágeis e indesejáveis, o que permite que apenas as melhores prossigam com o processo fermentativo. Além do mais, melhora o aroma e afina a cor da bebida

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos[,"freesulfurdioxide"])
summarytools::descr(vinhosTintos[,"freesulfurdioxide"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.freesulfurdioxide.boxplot = qplot(x = 1, y = freesulfurdioxide, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$freesulfurdioxide),max(vinhosBrancos.semOutliers$freesulfurdioxide))

vt.freesulfurdioxide.boxplot = qplot(x = 1, y = freesulfurdioxide, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$freesulfurdioxide),max(vinhosTintos.semOutliers$freesulfurdioxide))

vb.freesulfurdioxide.hist = create_histogram(vinhosBrancos.semOutliers, 'freesulfurdioxide', 6)
vt.freesulfurdioxide.hist = create_histogram(vinhosTintos.semOutliers, 'freesulfurdioxide', 1)

#Mostrando o resultado
plot_grid(vb.freesulfurdioxide.boxplot, vt.freesulfurdioxide.boxplot, vb.freesulfurdioxide.hist, vt.freesulfurdioxide.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Os dados na propriedade freesulfurdioxide (Livre de  Dióxido de Enxofre) são normalmente distribuídos.

No entanto, também existem alguns outliers potenciais, para os Vinhos Brancos quando se compara o valor máximo com o terceiro quartil. Portanto, os valores extremos serão removidos.

Dessa forma, iremos remover alguns outliers apenas dos Vinhos Brancos conforme abaixo:
```{r, echo = TRUE}
vinhosBrancos.semOutliers = vinhosBrancos.semOutliers[vinhosBrancos.semOutliers$freesulfurdioxide < 200, ]
```

Os gráficos abaixo foram gerados sem os outliers:

```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vbSemOutliers.freesulfurdioxide.boxplot = qplot(x = 1, y = freesulfurdioxide, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$freesulfurdioxide),max(vinhosBrancos.semOutliers$freesulfurdioxide))

vtSemOutliers.freesulfurdioxide.boxplot = qplot(x = 1, y = freesulfurdioxide, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$freesulfurdioxide),max(vinhosTintos.semOutliers$freesulfurdioxide))

vbSemOutliers.freesulfurdioxide.hist = create_histogram(vinhosBrancos.semOutliers, 'freesulfurdioxide', 2)
vtSemOutliers.freesulfurdioxide.hist = create_histogram(vinhosTintos.semOutliers, 'freesulfurdioxide', 1)

#Mostrando o resultado
plot_grid(vbSemOutliers.freesulfurdioxide.boxplot, vtSemOutliers.freesulfurdioxide.boxplot, vbSemOutliers.freesulfurdioxide.hist, vtSemOutliers.freesulfurdioxide.hist, labels = c("VB", "VT"), align = "v",ncol = 2)

```

E exibir novamente as estatisticas sobre eles, permitindo observar que a remoção dos outliers nos da uma visualização muito melhor sobre a distribuição dos dados.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"freesulfurdioxide"])
summarytools::descr(vinhosTintos.semOutliers[,"freesulfurdioxide"])
```

### Total de Dióxido de Enxofre (g/dm^3) - [8] "totalsulfurdioxide":
quantidade de formas livres e encadernadas de S02; em baixas concentrações, o SO2 é quase indetectável no vinho, mas nas concentrações de SO2 livre acima de 50 ppm, o SO2 se torna evidente no nariz e no sabor do vinho.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos[,"totalsulfurdioxide"])
summarytools::descr(vinhosTintos[,"totalsulfurdioxide"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.totalsulfurdioxide.boxplot = qplot(x = 1, y = totalsulfurdioxide, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$totalsulfurdioxide),max(vinhosBrancos.semOutliers$totalsulfurdioxide))

vt.totalsulfurdioxide.boxplot = qplot(x = 1, y = totalsulfurdioxide, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$totalsulfurdioxide),max(vinhosTintos.semOutliers$totalsulfurdioxide))

vb.totalsulfurdioxide.hist = create_histogram(vinhosBrancos.semOutliers, 'totalsulfurdioxide', 8)
vt.totalsulfurdioxide.hist = create_histogram(vinhosTintos.semOutliers, 'totalsulfurdioxide', 8)

#Mostrando o resultado
plot_grid(vb.totalsulfurdioxide.boxplot, vt.totalsulfurdioxide.boxplot, vb.totalsulfurdioxide.hist, vt.totalsulfurdioxide.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Os dados na propriedade totalsulfurdioxide (Total de Dióxido de Enxofre) são normalmente distribuídos.

### Densidade (g/cm^3) - [9] "density": 
a densidade é próxima à da água, dependendo do percentual de álcool e teor de açúcar.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos[,"density"])
summarytools::descr(vinhosTintos[,"density"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.density.boxplot = qplot(x = 1, y = density, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$density),max(vinhosBrancos.semOutliers$density))

vt.density.boxplot = qplot(x = 1, y = density, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$density),max(vinhosTintos.semOutliers$density))

vb.density.hist = create_histogram(vinhosBrancos.semOutliers, 'density', 0.001)
vt.density.hist = create_histogram(vinhosTintos.semOutliers, 'density', 0.00050)

#Mostrando o resultado
plot_grid(vb.density.boxplot, vt.density.boxplot, vb.density.hist, vt.density.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Os dados na propriedade density (Densidade) são normalmente distribuídos.

Geralmente, em condições padrão, a densidade da água é de 1,00 g/cm^3. Portanto, a densidade de uma solução na qual a água é o solvente deve ser um pouco menor que 1,00 g/cm^3. No gráfico acima, para os Vinhos Brancos, podemos observar pelo menos dois valores de densidade muitos maiores que 1,00 g/cm^3. Portanto, podemos remover esses valores do conjunto de dados. 

Dessa forma, iremos remover alguns outliers apenas dos Vinhos Brancos conforme abaixo:
```{r, echo = TRUE}

vinhosBrancos.semOutliers = vinhosBrancos.semOutliers[vinhosBrancos.semOutliers$density < 1.005, ]
```

Os gráficos abaixo foram gerados sem os outliers:

```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vbSemOutliers.density.boxplot = qplot(x = 1, y = density, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$density),max(vinhosBrancos.semOutliers$density))

vtSemOutliers.density.boxplot = qplot(x = 1, y = density, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$density),max(vinhosTintos.semOutliers$density))

vbSemOutliers.density.hist = create_histogram(vinhosBrancos.semOutliers, 'density', 0.00075)
vtSemOutliers.density.hist = create_histogram(vinhosTintos.semOutliers, 'density', 0.00075)

#Mostrando o resultado
plot_grid(vbSemOutliers.density.boxplot, vtSemOutliers.density.boxplot, vbSemOutliers.density.hist, vtSemOutliers.density.hist, labels = c("VB", "VT"), align = "v",ncol = 2)

```

E exibir novamente as estatisticas sobre eles, permitindo observar que a remoção dos outliers nos da uma visualização muito melhor sobre a distribuição dos dados.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"density"])
summarytools::descr(vinhosTintos.semOutliers[,"density"])
```

### pH - [10] "pH": 
descreve como o vinho é acídico ou básico numa escala de 0 (muito ácido) a 14 (muito básico); a maioria dos vinhos tem entre 3-4 na escala de pH.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"pH"])
summarytools::descr(vinhosTintos.semOutliers[,"pH"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.pH.boxplot = qplot(x = 1, y = pH, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$pH),max(vinhosBrancos.semOutliers$pH))

vt.pH.boxplot = qplot(x = 1, y = pH, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$pH),max(vinhosTintos.semOutliers$pH))

vb.pH.hist = create_histogram(vinhosBrancos.semOutliers, 'pH', 0.05)
vt.pH.hist = create_histogram(vinhosTintos.semOutliers, 'pH', 0.05)

#Mostrando o resultado
plot_grid(vb.pH.boxplot, vt.pH.boxplot, vb.pH.hist, vt.pH.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Os dados na propriedade pH são normalmente distribuídos. E se comparado com outras propriedades, os valores de pH mostram melhor distribuição gaussiana.

### Sulfatos (g/dm^3) - [11] "sulphates":
um aditivo de vinho que pode contribuir para os níveis de gás de dióxido de enxofre (S02), que age como um antimicrobiano e antioxidante.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"sulphates"])
summarytools::descr(vinhosTintos.semOutliers[,"sulphates"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.sulphates.boxplot = qplot(x = 1, y = sulphates, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$sulphates),max(vinhosBrancos.semOutliers$sulphates))

vt.sulphates.boxplot = qplot(x = 1, y = sulphates, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$sulphates),max(vinhosTintos.semOutliers$sulphates))

vb.sulphates.hist = create_histogram(vinhosBrancos.semOutliers, 'sulphates', 0.02)
vt.sulphates.hist = create_histogram(vinhosTintos.semOutliers, 'sulphates', 0.02)

#Mostrando o resultado
plot_grid(vb.sulphates.boxplot, vt.sulphates.boxplot, vb.sulphates.hist, vt.sulphates.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

Os dados na propriedade sulphates (Sulfatos) são normalmente distribuídos.

### Percentual alcólico (% by volume) - [12] "alcohol": 
o teor alcoólico percentual do vinho.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"alcohol"])
summarytools::descr(vinhosTintos.semOutliers[,"alcohol"])
```
```{r, echo = FALSE}
## Realizando o plot do boxplot
vb.alcohol.boxplot = qplot(x = 1, y = alcohol, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$alcohol),max(vinhosBrancos.semOutliers$alcohol))

vt.alcohol.boxplot = qplot(x = 1, y = alcohol, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$alcohol),max(vinhosTintos.semOutliers$alcohol))

vb.alcohol.hist = create_histogram(vinhosBrancos.semOutliers, 'alcohol', 0.5)
vt.alcohol.hist = create_histogram(vinhosTintos.semOutliers, 'alcohol', 1)

#Mostrando o resultado
plot_grid(vb.alcohol.boxplot, vt.alcohol.boxplot, vb.alcohol.hist, vt.alcohol.hist, labels = c("VB", "VT"), align = "v",ncol = 2)

```

Os dados na propriedade alcohol (Álcool) demonstram uma distribuição distorcida, assim como os cloretos ou açucares residuais, mas aqui a assimetria é menor.

### Qualidade do vinho - [13] "quality": 
propriedade de saída (com base em dados sensoriais) que poderiam ser de 0 a 10 sendo zero muito ruim e 10 muito excelente.

```{r, echo = FALSE, multi.col=T}
cat(paste0('Total de vinhos Brancos - Bons = ', nrow(subset(vinhosBrancos.semOutliers,
                                                            vinhosBrancos.semOutliers$quality.cat == 'good')),
'\nTotal de vinhos Brancos - Médios = ', nrow(subset(vinhosBrancos.semOutliers,
                                                     vinhosBrancos.semOutliers$quality.cat == 'medium')),
'\nTotal de vinhos Brancos - Ruins = ', nrow(subset(vinhosBrancos.semOutliers,
                                                    vinhosBrancos.semOutliers$quality.cat == 'bad'))))

cat(paste0('Total de vinhos Tintos - Bons = ', nrow(subset(vinhosTintos.semOutliers,
                                                           vinhosTintos.semOutliers$quality.cat == 'good')),
'\nTotal de vinhos Tintos - Médios = ', nrow(subset(vinhosTintos.semOutliers,
                                                    vinhosTintos.semOutliers$quality.cat == 'medium')),
'\nTotal de vinhos Tintos - Ruins = ', nrow(subset(vinhosTintos.semOutliers,
                                                   vinhosTintos.semOutliers$quality.cat == 'bad'))))
```

Estes resultados demonstram que grande parte dos vinhos da base de dados é de qualidade média.

### Tipo do Vinho - [14] "Vinho": 
```{r, echo = FALSE, multi.col=T}
cat(paste0('Total de vinhos Brancos = ', nrow(subset(vinhos,vinhos$Vinho == 'WHITE'))))
cat(paste0('Total de vinhos Tinto = ', nrow(subset(vinhos,vinhos$Vinho == 'RED'))))
```

### Acidez total do vinho [15] "totalacidity": 
propriedade criada com base nas propriedades "fixedacidity", "volatileacidity" e "citricacid" quem compoem a acidez total do vinho.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"totalacidity"])
summarytools::descr(vinhosTintos.semOutliers[,"totalacidity"])
```
```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vb.totalacidity.boxplot = qplot(x = 1, y = totalacidity, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$totalacidity),max(vinhosBrancos.semOutliers$totalacidity))

vt.totalacidity.boxplot = qplot(x = 1, y = totalacidity, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$totalacidity),max(vinhosTintos.semOutliers$totalacidity))

vb.totalacidity.hist = create_histogram(vinhosBrancos.semOutliers, 'totalacidity')
vt.totalacidity.hist = create_histogram(vinhosTintos.semOutliers, 'totalacidity')

#Mostrando o resultado
plot_grid(vb.totalacidity.boxplot, vt.totalacidity.boxplot, vb.totalacidity.hist, vt.totalacidity.hist, labels = c("VB", "VT"), align = "v",ncol = 2)
```

A Acidez Total, nos mostra que os dados na propriedade são normalmente distribuídos.

No entanto, também existem alguns outliers potenciais, para os Vinhos Brancos quando se compara o valor máximo com o terceiro quartil. Portanto, os valores extremos serão removidos.

Dessa forma, iremos remover alguns outliers apenas dos Vinhos Brancos conforme abaixo:
```{r, echo = TRUE}

vinhosBrancos.semOutliers = vinhosBrancos.semOutliers[vinhosBrancos.semOutliers$totalacidity < 12, ]
```

Os gráficos abaixo foram gerados sem os outliers:


```{r, echo = FALSE}
## Realizando o plot do histogram e boxplot

#Alinhando os dois eixos.
vbSemOutliers.totalacidity.boxplot = qplot(x = 1, y = totalacidity, data = vinhosBrancos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosBrancos.semOutliers$totalacidity),max(vinhosBrancos.semOutliers$totalacidity))

vtSemOutliers.totalacidity.boxplot = qplot(x = 1, y = totalacidity, data = vinhosTintos.semOutliers, xlab = "", geom = 'boxplot') + coord_flip() + ylim(min(vinhosTintos.semOutliers$totalacidity),max(vinhosTintos.semOutliers$totalacidity))

vbSemOutliers.totalacidity.hist = create_histogram(vinhosBrancos.semOutliers, 'totalacidity')
vtSemOutliers.totalacidity.hist = create_histogram(vinhosTintos.semOutliers, 'totalacidity')

#Mostrando o resultado
plot_grid(vbSemOutliers.totalacidity.boxplot, vtSemOutliers.totalacidity.boxplot, vbSemOutliers.totalacidity.hist, vtSemOutliers.totalacidity.hist, labels = c("VB", "VT"), align = "v", ncol = 2)
```

E exibir novamente as estatisticas sobre eles, permitindo observar que a remoção dos outliers nos da uma visualização muito melhor sobre a distribuição dos dados.

```{r, echo = FALSE, multi.col=T}
summarytools::descr(vinhosBrancos.semOutliers[,"totalacidity"])
summarytools::descr(vinhosTintos.semOutliers[,"totalacidity"])
```

## Análise dos Dados

Para termos uma ideia geral dos dados, são listados abaixo apenas os 6 primeiros registros:
```{r, echo = FALSE}
head(vinhos)
```

### Análise Bivariada

A partir da análise uni-variante na seção acima, reflete alguns insights de atributos individuais no conjunto de dados. Nesta seção, as correlações entre os atributos foram investigadas.

Para entender as relações entre os atributos, foi gerada a seguinte matriz de gráficos de correlação. A matriz de gráficos é vantajosa para esse tipo de análise, porque todas as relações entre as variáveis podem ser facilmente identificadas. É útil implementar uma análise adicional do conjunto de dados.

```{r cols.print=30, rows.print=3, echo = FALSE, cache=TRUE}
vinhosBrancos.fact <- vinhosBrancos.semOutliers %>% mutate_if(is.factor, as.numeric)
vinhosTintos.fact <- vinhosTintos.semOutliers %>% mutate_if(is.factor, as.numeric)
vinhosBrancos.fact %>% union(vinhosTintos.fact) -> vinhos.fact
```

## Correlation, Variance and Covariance (Matrices)

A seguir, iremos gerar um mapa de calor das correlações para cada tipo de vinho.

### Vinhos Brancos:

```{r CorrelationsVB, echo = FALSE, warning=F, message=F}
#par(mfrow=c(2,2))

#vinhos.fact %>% filter(Vinho == 2) -> vinhosBrancos.fact
cor(vinhosBrancos.fact %>% dplyr::select(.,-c('id_vinho','Vinho'))) -> vinhosBrancos.cor
corrplot(vinhosBrancos.cor, method = "number")
```

### Vinhos Tintos:

```{r CorrelationsVT, echo = FALSE, warning=F, message=F}
#vinhos.fact %>% filter(Vinho == 1) -> vinhosTintos.fact
cor(vinhosTintos.fact %>% dplyr::select(.,-c('id_vinho','Vinho'))) -> vinhosTintos.cor
corrplot(vinhosTintos.cor, method = "number")
```

Nas figuras acima, a dispersão de cada atributo com os outros e os coeficientes de correlação correspondentes são mostrados. Na diagonal do diagrama, os gráficos de densidade são exibidos para cada atributo.

Quando se examina o coeficiente de correlação para cada relação nas figuras acima, alguns dos atributos parecem ser de alta a moderadamente correlacionados entre si. 

Precebemos também que a propriedade Total Acidity (totalacidity), criada por nós no início destas análises sempre indica valores de correlação com outras propriedades iguais as correlações dessas outras propriedades com a propriedade Fixed Acidity (fixedacidity). Dessa forma, iremos remover essa propriedade das análises.

### Vinhos Brancos (Filtrado):

```{r CorrelationsVB2, echo = FALSE, warning=F, message=F}
#par(mfrow=c(2,2))

#vinhosBrancos.cor <- cor(select(vinhosBrancos.fact, -c('id_vinho', 'Vinho', 'totalacidity')))
cor(vinhosBrancos.fact %>% dplyr::select(.,-c('id_vinho','Vinho', 'totalacidity'))) -> vinhosBrancos.cor
corrplot(vinhosBrancos.cor, method = "number")
```

### Vinhos Tintos (Filtrado):

```{r CorrelationsVT2, echo = FALSE, warning=F, message=F}
#vinhosTintos.cor <- cor(select(vinhosTintos.fact, -c('id_vinho', 'Vinho', 'totalacidity')))
cor(vinhosTintos.fact %>% dplyr::select(.,-c('id_vinho','Vinho', 'totalacidity'))) -> vinhosTintos.cor
corrplot(vinhosTintos.cor, method = "number")
```

**Dessa forma, com os novos dados de correlação, temos:**

Por exemplo, para os Vinhos Brancos, os coeficientes de correlação das propriedadesabaixo são: <br/>
&nbsp;&nbsp;**- Álcool (alcohol) vs Densidade (density) = -0.80** <br/>
&nbsp;&nbsp;**- Açúcar Residual (residualsugar) vs Densidade (density) = 0.84** <br/>
&nbsp;&nbsp;**- Dióxido de Enxofre Total (totalsulfurdioxide) vs Densidade (density) = 0.54** <br/>
&nbsp;&nbsp;**- Dióxido de Enxofre Total (totalsulfurdioxide) vs Dióxido de Enxofre Livre (freesulfurdioxide) = 0.62** <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A correlação entre Dióxido de Enxofre Total (totalsulfurdioxide) e Dióxido de Enxofre Livre (freesulfurdioxide) será desconsiderada, devido ao fato de que uma propriedade compreende a outra.

Já para os Vinhos Tintos, os coeficientes de correlação são: <br/>
&nbsp;&nbsp;**- pH vs Acidez Fixa (fixedacidity) = -0.68** <br/>
&nbsp;&nbsp;**- pH vs Ácido Cítrico (citricacid) = -0.54** <br/>
&nbsp;&nbsp;**- Densidade (density) vs Acidez Fixa (fixedacidity) = 0.67** <br/>
&nbsp;&nbsp;**- Dióxido de Enxofre Total (totalsulfurdioxide) vs Dióxido de Enxofre Livre (freesulfurdioxide) = 0.67** <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A correlação entre Dióxido de Enxofre Total (totalsulfurdioxide) e Dióxido de Enxofre Livre (freesulfurdioxide) será desconsiderada, devido ao fato de que uma propriedade compreende a outra. <br/>
&nbsp;&nbsp;**- Ácido Cítrico (citricacid) vs Acidez Fixa (fixedacidity) = 0.67** <br/>
&nbsp;&nbsp;**- Ácido Cítrico (citricacid) vs Acidez Voláil (volatileacidity) = -0.55** <br/>

No entanto, se compararmos as correlações entre os dois tipos de vinhos temos:

```{r CorrelationsV, echo = FALSE, warning=F, message=F}
#vinhos.cor <- cor(select(vinhos.fact, -c('id_vinho', 'Vinho')))
cor(vinhos.fact %>% dplyr::select(.,-c('id_vinho','Vinho'))) -> vinhos.cor
corrplot(vinhos.cor, method = "number")
```

Nas seções abaixo, cada uma dessas relações de alta a moderada será investigada:

### Vinhos Brancos (Análise das Correlações)

- **Álcool (alcohol) vs Densidade (density) = -0.80**
  
  O álcool tem correlação negativa com a densidade. Isto é evidente pelo fato de que a densidade da água é maior que a densidade do álcool.
  
```{r echo=F, fig.show = 'hold', out.width = '100%'}
vinhosBrancos.fact$quality.cat.fact <- factor(vinhosBrancos.fact$quality.cat, ordered = T)
ggplot(data = vinhosBrancos.fact, aes(y = density, x = alcohol, color = quality.cat.fact)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)  +
  scale_color_brewer(type = 'seq', guide = guide_legend(title = 'Quality'))
```

- **Açúcar Residual (residualsugar) vs Densidade (density) = 0.84**

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhosBrancos.fact, aes(y = residualsugar, x = density, color = quality.cat.fact)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)  +
  facet_wrap(~quality.cat) +
  scale_color_brewer(type = 'seq', guide = guide_legend(title = 'Quality'))
```

- **Dióxido de Enxofre Total (totalsulfurdioxide) vs Densidade (density) = 0.54**

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhosBrancos.fact, aes(y = totalsulfurdioxide, x = density, color = quality.cat.fact)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)  +
  facet_wrap(~quality.cat) +
  scale_color_brewer(type = 'seq', guide = guide_legend(title = 'Quality'))
```

### Vinhos Tintos (Análise das Correlações)

- **pH vs Acidez Fixa (fixedacidity) = -0.68**

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.show = 'hold', out.width = '100%'}
vinhosTintos.fact$quality.cat.fact <- factor(vinhosTintos.fact$quality.cat, ordered = T)
ggplot(data = vinhosTintos.fact, aes(x = fixedacidity, y = pH, color = quality.cat.fact)) +
  geom_point(alpha = 0.3) +
  scale_x_log10(breaks = seq(5,15,1)) +
  xlab("Fixed Acidity in Log Scale") +
  geom_smooth(method = "lm")
```

- **pH vs Ácido Cítrico (citricacid) = -0.54**

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.show = 'hold', out.width = '100%'}
ggplot(data = subset(vinhosTintos.fact, citricacid > 0), aes(x = citricacid, y = pH, color = quality.cat.fact)) +
  geom_point(alpha = 0.3) +
  scale_x_log10() +
  xlab("Citric Acid in Log Scale") +
  geom_smooth(method = "lm")
```

- **Densidade (density) vs Acidez Fixa (fixedacidity) = 0.67**

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhosTintos.fact, aes(y = density, x = fixedacidity, color = quality.cat.fact)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)  +
  facet_wrap(~quality.cat) +
  scale_color_brewer(type = 'seq', guide = guide_legend(title = 'Quality'))
```

- **Ácido Cítrico (citricacid) vs Acidez Fixa (fixedacidity) = 0.67**

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhosTintos.fact, aes(y = citricacid, x = fixedacidity, color = quality.cat.fact)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)  +
  facet_wrap(~quality.cat) +
  scale_color_brewer(type = 'seq', guide = guide_legend(title = 'Quality'))
```

- **Ácido Cítrico (citricacid) vs Acidez Voláil (volatileacidity) = -0.55**

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhosTintos.fact, aes(y = citricacid, x = volatileacidity, color = quality.cat.fact)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)  +
  facet_wrap(~quality.cat) +
  scale_color_brewer(type = 'seq', guide = guide_legend(title = 'Quality'))
```

### Todos os Vinhos (Análise das Correlações)

Após analisarmos os dados, percebemos que o tipo do vinho (Vinho) tem correlações significativas com algumas propriedades, como por exemplo: <br/>
&nbsp;&nbsp;**- Acidez Voláil (volatileacidity) = -0.65** <br/>
&nbsp;&nbsp;**- Cloretos (chlorides) = -0.51** <br/>
&nbsp;&nbsp;**- Dióxido de Enxofre Total (totalsulfurdioxide) = 0.70** <br/>

- **Acidez Voláil (volatileacidity) = -0.65**

```{r echo=FALSE, message=FALSE, warning=FALSE}
vinhos.fact$quality.cat.fact <- factor(vinhos.fact$quality.cat, ordered = T)

ggplot(data = vinhos.fact, aes(y = Vinho, x = volatileacidity)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)
```

- **Cloretos (chlorides) = -0.51**

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(y = Vinho, x = chlorides)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1)  
```

- **Dióxido de Enxofre Total (totalsulfurdioxide) = 0.70**

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(y = Vinho, x = totalsulfurdioxide)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_smooth(method = "lm", se = FALSE, size = 1) 
```

Para os dois tipos de vinhos, um ponto que chamou nossa atenção é que não encontramos uma correlação positiva forte entre o pH e a Acidez Volátil. Este ponto nos deixo muito curiosos já que quanto menor o pH, maior é a acidez. Dessa forma aprofundamos essa investigação e descobrimos a existencia de uma fenômeno chamado **Simpson Paradox**.

> "O paradoxo de Simpson (ou reversão de Simpson, efeito Yule-Simpson, paradoxo de amalgamação ou paradoxo de reversão) [1] é um fenômeno em probabilidade e estatística, em que uma tendência aparece em vários grupos diferentes de dados, mas desaparece ou reverte quando esses grupos são combinados .
   Este resultado é freqüentemente encontrado em estatísticas de ciências sociais e ciências médicas [2] [3] [4] e é particularmente problemático quando dados de frequência são indevidamente dadas interpretações causais. [5] O paradoxo pode ser resolvido quando as relações causais são apropriadamente atendidas na modelagem estatística. [5] [6] Ele tem sido usado para tentar informar o público não especialista ou público sobre o tipo de resultados enganosos que estatísticas erradas podem gerar. [7] [8] Martin Gardner escreveu um relato popular do paradoxo de Simpson em sua coluna de Jogos Matemáticos de março de 1976 na revista Scientific American. [9]" 

(fonte: https://en.wikipedia.org/wiki/Simpson%27s_paradox)

**Dessa forma, iremos realizar alguns boxplots combinando propriedades para tentar identificar correlações perdidas:**

<span style="color:red">Para os gráficos a seguir, devemos considerar para a propriedade qualidade, quanto mais alta, melhor a qualidade do vinho.</span>

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x = quality.cat.fact, y = fixedacidity)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

Como podemos ver, a Acidez Fixa não tem quase nenhum efeito na Qualidade. Os valores médios e medianos da acidez fixa permanecem quase inalterados com o aumento da qualidade.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x = quality.cat.fact, y = volatileacidity)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

O ácido volátil parece ter um impacto negativo na qualidade do vinho. À medida que o nível de ácido volátil aumenta, a qualidade do vinho degrada.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x = quality.cat.fact, y = citricacid)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

O ácido cítrico parece ter uma correlação positiva com a qualidade do vinho. Melhores vinhos têm maior ácido cítrico.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x = quality.cat.fact, y = residualsugar)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  scale_y_continuous(lim = c(0,5)) +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

O gráfico acima nos mostra que o Açúcar Residual quase não tem efeito sobre a Qualidade do Vinho. Os valores médios do açúcar residual são quase os mesmos para todas as qualidades de vinho.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x=quality.cat.fact, y=chlorides)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  scale_y_continuous(lim = c(0,0.2)) +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

Embora fracamente correlacionado, a partir da diminuição dos valores médios dos cloretos com o aumento da qualidade, aparentemente uma porcentagem menor de Cloreto parece produzir melhores vinhos.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x=quality.cat.fact, y=freesulfurdioxide)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  scale_y_continuous(lim = c(0,40)) +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

Acima, vemos que uma concentração muito baixa de dióxido de enxofre livre produz vinho pobre e uma concentração muito alta resulta em vinho médio.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x=quality.cat.fact, y=totalsulfurdioxide)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  scale_y_continuous(lim = c(0,150)) +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

Como este é um subconjunto de dióxido de enxofre livre, vemos um padrão semelhante aqui.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x=quality.cat.fact, y=density)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

Melhores vinhos parecem ter densidades mais baixas. No entanto, não iremos tirar nenhuma conclusão ainda sobre este ponto porque pode haver uma possibilidade de que a baixa densidade seja devida ao maior teor de álcool, que na verdade é o fator determinante para melhores vinhos.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x = quality.cat.fact, y = pH)) +
  geom_jitter( alpha = .3) +
  geom_boxplot(alpha = .5,color = 'blue') +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = 8, size = 4)
```

Melhores vinhos parecem ter menos pH, ou seja, são mais ácidos. Mas há alguns outliers aqui. Então, talvez a próxima coisa lógica seria ver como os ácidos individuais afetam o pH.

```{r echo=FALSE, message=FALSE, warning=FALSE}

ggplot(data = vinhos.fact, aes(x = fixedacidity, y = pH)) +
  geom_point(alpha = 0.3) +
  scale_x_log10(breaks = seq(5,15,1)) +
  xlab("Fixed Acidity in Log Scale") +
  geom_smooth(method = "lm")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = vinhos.fact, aes(x = volatileacidity, y = pH)) +
  geom_point(alpha = 0.3) +
  scale_x_log10(breaks = seq(.1,1,.1)) +
  xlab("Volatile Acidity in Log Scale") +
  geom_smooth(method = "lm")
```


```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = subset(vinhos.fact, citricacid > 0), aes(x = citricacid, y = pH)) +
  geom_point(alpha = 0.3) +
  scale_x_log10() +
  xlab("Citric Acid in Log Scale") +
  geom_smooth(method = "lm")
```


----------------------------------------------------------------------------------------------


# REGREÇÃO LINEAR

Como pode ser observado nos topicos abordados acima algumas propriedades como a densidade, o teor de açúcar, a porcentagem de álcool e o teor de dióxido de enxofre desempenham papeis significativos na qualidade dos vinhos. Dessa forma, iremos criar uma análise de regressão múltipla para determinar uma relação, se houver, entre esses parâmetros.

```{r, echo = FALSE, regressaolinearmultipla1}
fit = lm(density ~ totalsulfurdioxide + citricacid + chlorides, data = vinhos.fact)
summary(fit)
```

Neste modelo de regressão linear múltipla, o coeficiente de correlação da densidade versus outros parâmetros selecionados melhorou para 9,91 do coeficiente de parâmetro individual máximo anterior.

Portanto, os parâmetros do modelo são estatisticamente significativos. Isso indica a robustez do modelo.


#### Validando o modelo

Realizaremos a validação do modelo através dos gráficos de caracterização e os histogramas.

As principais suposições para validar um modelo linear são as seguintes:

* As variáveis devem ser independentes umas das outras.
* As variáveis individuais devem ser distribuídas normalmente.
* Os resíduos não devem mostrar padrões específicos.

Como todas essas suposições são preenchidas pelas variáveis selecionadas no modelo, a validade do modelo é confirmada.


O gráfico a seguir mostra as densidades previstas usando o modelo de regressão derivado na seção acima.

```{r, echo = FALSE, regressaolinearmultipla2}
## gerando uma nova variável (densidade prevista)
intercept = 9.916e-01
coef1 = 6.994e-06  
coef2 = 1.057e-03  
coef3 = 3.363e-02


vinhos.fact$predict_density = vinhos.fact$totalsulfurdioxide * (coef1) +
                              vinhos.fact$citricacid * (coef2) +
                              vinhos.fact$chlorides * (coef3) + intercept


```

```{r, echo = TRUE, regressaolinearmultipla3}
## Gerando modelo de regressão linear simples
fit2 = lm(predict_density ~ density, data = vinhos.fact)

## Plot o modelo
ggplot(aes(density , predict_density), data = vinhos.fact) +
            geom_point(aes(color= quality.cat), alpha = 1/3, position = position_jitter(h = 0)) +
            geom_abline(intercept = coef(fit2)[1], slope = coef(fit2)[2], col = 'red') +
            xlab("Density (g/cm^3)") +
            ylab("Predicted density (g/cm^3)") 
```

No gráfico acima vemos o modelo de regressão linear múltipla demonstrado na linha vermelha. Já os pontos azuis são as densidades medidas e as densidades calculadas para os vinhos. 

Além disso, os pontos em tonalidades azuais marcam as qualidades dos vinhos. Baseado neste gráfico podemos analisar que com base neste modelo, a qualidade do vinho pode ser determinada para a maioria dos vinhos pela sua densidade.

Uma das dificuldades deste conjunto de dados que enfrentamos é que diversas variáveis do dataset estão relacionadas a propriedades técnicas dos vinhos. Para tentar melhor entender essas propriedades técnicas, tentamos buscar mais informações na internet dobre elas. Por exemplo, os valores de densidade de
o vinho não podem exceder 1,00 g/cm^3, dessa forma, estabelecemos nosso limite de outlier como 1.005. No entanto, diversas outras propriedades técnicas certamente nos passaram desapercebidas nessa análise.


# REGRESSÃO LOGISTICA
```{r echo=FALSE}
#WANDER
```

```{r echo=FALSE, message=FALSE, warning=FALSE, packageswander}
## Instalando os pacotes requeridos
list.of.packages <- c("rpart", "dplyr", "corrgram", "corrplot", "plotly", "klaR", "plotly", "dplyr", "rms", "car", "readr", "ggplot2", "corrplot", "caret", "data.table", "rpart.plot", "rattle", "MASS", "ROCR")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if (length(new.packages)) {
  install.packages(new.packages, dependencies = T)
}
## Carregando os pacotes
for (package_name in list.of.packages)
{library(package_name, character.only = TRUE, quietly = TRUE);}
```

```{r echo=FALSE}
dados = data.table::copy(vinhos)
```

***Definição da variável resposta***

A variavel quality foi escolhida como target ou alvo conforme solicitado, para usar na regressão logistica tivemos que tranformar esta variavel em uma categorica, em nosso caso  binaria sendo 1 ou 0.
De tal forma que 1 são vinhos bons onde o quality é igual ou superior a 6 e 0 os demais vinhos  sendo eles classificados como ruins tais quais inferiores a 6.


```{r}
dados$quality <- ifelse(dados$quality>=6, yes = 1,no = 0)
```

Transformando vinho em numeros

```{r}
dados$Vinho<- as.numeric( dados$Vinho)
```

Removendo a coluna vinho porque nossa analise consiste nas caracteristicas quimicas dos vinhos por isso não faz sentido para nossa analise deixar este indexador

```{r}
dados %>% dplyr::select(.,-c('id_vinho')) -> dados
```

## Vinhos Brancos

```{r}
dados <- dados[dados$Vinho==2,]
```


```{r}
dados$quality<-factor(dados$quality)
```


```{r}
head(dados,3)
```



### Separando os dados de treino


```{r}
#trainIndex <- createDataPartition(dados$Vinho, p=0.70, list=FALSE)
prt <- 2/3
set.seed(999)
trainIndex <- sample(1:NROW(dados), as.integer(prt*NROW(dados)))
```

```{r}
set.seed(123)
dfTreino <- dados[ trainIndex,]
dfTeste <- dados[-trainIndex,]
```

### Análise Exploratória dos dados

A análise exploratória está contida no MarkDown onde é possível ver todas as etapas da análise exploratória e todos os recursos utilizados para melhor compreensão dos dados.


### Treinamento dos modelos e Validação 

### Regressão logistica Vinhos Brancos

A seguir iremos fazer o treinamento do modelo de regressão logistica. Para validarmos os modelos e garantir que o modelo 
tenha um desempenho aceitavel iremos treina-los com todas as variaveis e em seguida utilizarei o StepWise para selecionar 
as melhores variaveis. 

Apos estas etapas validaremos os resultados da acurracia do modelo, a matriz de confusão e geraremos uma curva ROC para ver o desempenho.

Definição da formula a ser usada no preditor, conforme mencionado acima o alvo ou target será a variavel "quality". 

As variaveis preditoras serão as demais.


```{r}
y= quality~fixedacidity+volatileacidity+citricacid+residualsugar+chlorides+freesulfurdioxide+totalsulfurdioxide+density+pH+sulphates+alcohol+Vinho
```

### Treinando o modelo com todas as variaveis

Usando GLM Treinaremos o modelo com a funcionalidade de regressão logistica, para alvos ou target binomiais ou seja variaveis categoricas binarias que possuam dois estados como valores binarios.


```{r}
modeloComTodasVariaveis <- glm(y, data = dfTreino, family=binomial(link="logit"))
```

### Exibindo as variaveis do modelo completo

Para treinar e validar o modelo exibiremos aqui as variaveis utilizadas no treino.
Em seguida iremos treinar o modelo com as variaveis selecionadas automaticamente para ver se melhoramos o desempenho.


```{r}
coef(modeloComTodasVariaveis)
```



Acima nota-se que temos 12 variaveis apontar isso é importante para exibir a funcionalidde onde o metodo escolhe as variaveis com mais significancia, e melhora o desempenho do nosso modelo.


```{r}
summary(modeloComTodasVariaveis)
```

### Usando Stepwise para Selecionar as melhores variaveis  

Aqui passamos o modelo como argumento para o metodo o qual nos retorna as variaveis mais importantes.


```{r}
modeloComStepWise <- modeloComTodasVariaveis %>% stepAIC( trace = FALSE)
```

### Exibindo as variaveis após utilizar o Stepwise

As variaveis mais significantes para o modelo são exibidas abaixo, 


```{r}
coef(modeloComStepWise)
```

Após a utilização do metodo notasse que o Stepwise selecionou 8 variaveis variaveis estas que são as mais significativas para o modelo.


```{r}
summary(modeloComStepWise)
```

### Fazendo a predição dos dados de testes usando o modelo com todas as variaveis 

```{r}
resultadoPredicaoTestes <- modeloComTodasVariaveis %>% predict(dfTeste, type = "response")
predicaoResultado <- ifelse(resultadoPredicaoTestes > 0.5, 1, 0)
```

### Calculando a precisão (accuracy) do modelo com todas as variaveis 

Abaixo o modelo exibe o calculo da precisão do modelo. Creio que para as particularidades da base de dados o resultado é otimo.


```{r}
mean(predicaoResultado == dfTeste$quality)
```



```{r}
resultadoPredicaoTestesStepwise <- predict(modeloComStepWise, dfTeste, type = "response",na.action = na.pass)
predicaoResultadoStepWise <- ifelse(resultadoPredicaoTestesStepwise > 0.5, 1, 0)
```

### Calculando a precisão (accuracy) do modelo com as variaveis escolhidas pelo modelo 


```{r}
mean(predicaoResultadoStepWise == dfTeste$quality)
```


0.748315982853644


Com a seleção de variaveis alem de diminuirmos a quantidade de variaveis, tambem obtivemos uma melhoria no modelo 
onde o mesmo beira cerca de 75% se arredondarmos, o que é otimo, mas para comprovar que o modelo é eficiente 
seguiremos buscando mais dados para comprovar

### Matriz de confusão com todos os dados


```{r}
confusionMatrix(data = as.factor(as.numeric(resultadoPredicaoTestes > 0.5)), reference = dfTeste$quality)
```

### Matriz de confusão com StepWise


```{r}
confusionMatrix(data = as.factor(as.numeric(predicaoResultadoStepWise > 0.5)), reference = dfTeste$quality)
```


```{r}
probabilidades = cbind(dfTeste,predicaoResultadoStepWise)
```


```{r}
vlrcalcPredPerformance = prediction(predicaoResultadoStepWise ,probabilidades$quality)
```

### Calculando a área sob a curva AUC                

```{r}
auc = performance(vlrcalcPredPerformance,"auc")

```

O resultado da curva ROC é excelente, do meu ponto 


```{r}
perf = performance(vlrcalcPredPerformance, "tpr", "fpr")
attr(perf, "y.values")[[1]][2]
```


Plotanto o grafico fica mais visivel a performance do modelo em relação a curva roc.


```{r}
plot(perf, col = "blue", lwd = 5)
lines(x = c(0,1),y=c(0,1))
```

## Vinhos Vermelhos

```{r}
dados = data.table::copy(vinhos)
```


```{r}
dados$quality <- ifelse(dados$quality>=6, yes = 1,no = 0)
dados$Vinho<- as.numeric( dados$Vinho)
```


```{r}
dim(dados)
```


Removendo a coluna vinho porque nossa analise consiste nas caracteristicas quimicas dos vinhos por isso não faz sentido para nossa analise deixar este indexador


```{r}
dados %>% dplyr::select(.,-c('id_vinho')) -> dados
```

### Selecionando os vinhos Brancos para analisar usando a regressão logistica


```{r}
dados <- dados[dados$Vinho==1,]
dados$quality<-factor(dados$quality)
head(dados,3)
```

### Separando os dados de treino


```{r}
set.seed(123)
prt <- 2/3
set.seed(10)
trainIndex <- sample(1:NROW(dados), as.integer(prt*NROW(dados)))
dfTreino <- dados[ trainIndex,]
dfTeste <- dados[-trainIndex,]
```

### Análise Exploratória dos dados

A análise exploratória está contida no MarkDown onde é possível ver todas as etapas da análise exploratória e todos os recursos utilizados para melhor compreensão dos dados.



### Treinamento dos modelos e Validação 

### Regressão logistica Vinhos Brancos

A seguir iremos fazer o treinamento do modelo de regressão logistica. Para validarmos os modelos e garantir que o modelo 
tenha um desempenho aceitavel iremos treina-los com todas as variaveis e em seguida utilizarei o StepWise para selecionar 
as melhores variaveis. 

Apos estas etapas validaremos os resultados da acurracia do modelo, a matriz de confusão e geraremos uma curva ROC para ver o desempenho.


## Definição da formula a ser usada no preditor, conforme mencionado acima o alvo ou target será a variavel "quality". 

As variaveis preditoras serão as demais.

```{r}
y= quality~fixedacidity+volatileacidity+citricacid+residualsugar+chlorides+freesulfurdioxide+totalsulfurdioxide+density+pH+sulphates+alcohol+Vinho
```

### Treinando o modelo com todas as variaveis

Usando GLM Treinaremos o modelo com a funcionalidade de regressão logistica, para alvos ou target binomiais ou seja variaveis categoricas binarias que possuam dois estados como valores binarios.


```{r}
modeloComTodasVariaveis <- glm(y, data = dfTreino, family=binomial(link="logit"))
```

### Exibindo as variaveis do modelo completo

Para treinar e validar o modelo exibiremos aqui as variaveis utilizadas no treino.
Em seguida iremos treinar o modelo com as variaveis selecionadas automaticamente para ver se melhoramos o desempenho.



```{r}
coef(modeloComTodasVariaveis)
```



Acima nota-se que temos 12 variaveis apontar isso é importante para exibir a funcionalidde onde o metodo escolhe as variaveis com mais significancia, e melhora o desempenho do nosso modelo.


```{r}
summary(modeloComTodasVariaveis)
```



### Usando Stepwise para Selecionar as melhores variaveis  

Aqui passamos o modelo como argumento para o metodo o qual nos retorna as variaveis mais importantes.


```{r}
modeloComStepWise <- modeloComTodasVariaveis %>% MASS::stepAIC( trace = FALSE)
```

### Exibindo as variaveis após utilizar o Stepwise

As variaveis mais significantes para o modelo são exibidas abaixo, 



```{r}
coef(modeloComStepWise)
```

Após a utilização do metodo notasse que o Stepwise selecionou 10 variaveis variaveis estas que são as mais significativas para o modelo.


```{r}
summary(modeloComStepWise)
```

### Fazendo a predição dos dados de testes usando o modelo com todas as variaveis 


```{r}
resultadoPredicaoTestes <- modeloComTodasVariaveis %>% predict(dfTeste, type = "response")
predicaoResultado <- ifelse(resultadoPredicaoTestes > 0.5, 1, 0)
```

### Calculando a precisão (accuracy) do modelo com todas as variaveis 

Abaixo o modelo exibe o calculo da precisão do modelo. Creio que para as particularidades da base de dados o resultado é otimo.


```{r}
mean(predicaoResultado == dfTeste$quality)
```

```{r}
resultadoPredicaoTestesStepwise <- predict(modeloComStepWise, dfTeste, type = "response",na.action = na.pass)
predicaoResultadoStepWise <- ifelse(resultadoPredicaoTestesStepwise > 0.5, 1, 0)
```

### Calculando a precisão (accuracy) do modelo com as variaveis escolhidas pelo modelo 


```{r}
mean(predicaoResultadoStepWise == dfTeste$quality)
```

Com a seleção de variaveis apesar de diminuirmos a quantidade de variaveis, nosso modelo diminuiu sua precisão, neste caso é melhor utilizar o modelo com todas as variaveis para ter uma precisão perto de 75% o que já é valor muito aceitavel


### Matriz de confusão com todos os dados



```{r}
caret::confusionMatrix(data = as.factor(as.numeric(resultadoPredicaoTestes > 0.5)), reference = dfTeste$quality)
```

### Matriz de confusão com StepWise


```{r}
caret::confusionMatrix(data = as.factor(as.numeric(predicaoResultadoStepWise > 0.5)), reference = dfTeste$quality)
```

```{r}
probabilidades = cbind(dfTeste,predicaoResultadoStepWise)
```


```{r}
vlrcalcPredPerformance = prediction(predicaoResultadoStepWise ,probabilidades$quality)
```

### Calculando a área sob a curva AUC                


```{r}
auc = performance(vlrcalcPredPerformance,"auc")
perf = performance(vlrcalcPredPerformance, "tpr", "fpr")
```

O resultado da curva ROC é excelente, do meu ponto 

```{r}
attr(perf, "y.values")[[1]][2]
```

Plota curva ROC

```{r}
plot(perf, col = "blue", lwd = 5)
lines(x = c(0,1),y=c(0,1))
```

Com o plot do grafico dá pra ver a eficiencia e é possivel notar a ponta da reta acima de 0,80

## Conclusões sobre a Regressão Logistica

Com a métrica correta faça a comparam entre os diferentes os algoritmos e qual foi o melhor entre eles.
A comparação da execução do modelo de forma individual mostrou que para classificar os vinhos Vermelhos o preditor se saiu melhor onde o UAC foi de 0.84 contra 0.74 dos vinhos brancos.

Ainda na classificação dos vinhos vermelhos quando utilizamos o StepWise a performance do modelo diminui de 0.74 para 0.73 com stepwise, porem o stepwise diminui a quantidade de variaveis selecionando somente as que tem maior importancia.

Na classificação dos vinhos brancos a Accuracia é de 0.7502  quando selecionamos o modelo com todas as variaveis, porem o desempenho diminui quando usamos stepwise para 0.7483 uma perda pequena e tambem ocorre uma diminuição dos parametros necessarios para predizer ou seja as variaveis preditoras não são todas utilizadas.

Ao analisar as matrizes de confusão dos vinhos brancos com e sem stepwise e os vinhos vermelhos com e sem stepwize notasse baixa diferença na acurracia da matriz de confução o que torna este preditor qualificado a entrar em produção.

```{r echo=F}
#MARCELO
```
# ANÁLISE DE CLUSTERS

A analise de clusters foi dividida em 2. Em um primeiro momento fazemos toda a analise sem PCA e depois com PCA. 

Isso e feito para que possamos cruzar os dados obtidos das duas formas.

## Sem PCA

Como ja notamos, os vinhos precisam ser divididos em vermelhos e brancos, para a clusterizacao vamos trabalhar com 3 cenarios:
- Todos juntos
- Brancos
- Vermelhos

```{r}
wineCust <- vinhos
winecust_red <- vinhosTintos
winecust_white <- vinhosBrancos
```

Para que possamos entender a correlacao, vamos normalizar os datasets:
```{r}
#wineCust_scale <- scale(select (wineCust,-c(Vinho,id_vinho)))
#scale(wineCust %>% dplyr::select(.,-c('id_vinho','Vinho'))) -> wineCust_scale
scale(vinhos.fact %>% dplyr::select(.,-c('id_vinho','Vinho','quality.cat','quality.cat.fact','predict_density'))) -> wineCust_scale
summary(wineCust_scale)

#wineCust_red_scale <- scale(select (winecust_red,-c(Vinho,id_vinho)))
#scale(winecust_red %>% dplyr::select(.,-c('id_vinho','Vinho'))) -> wineCust_red_scale
scale(vinhosTintos.fact %>% dplyr::select(.,-c('id_vinho','Vinho','quality.cat','quality.cat.fact'))) -> wineCust_red_scale
summary(wineCust_red_scale)

#wineCust__white_scale <- scale(select (winecust_white,-c(Vinho,id_vinho)))
#scale(winecust_white %>% dplyr::select(.,-c('id_vinho','Vinho'))) -> wineCust__white_scale
scale(vinhosBrancos.fact %>% dplyr::select(.,-c('id_vinho','Vinho','quality.cat','quality.cat.fact'))) -> wineCust__white_scale
summary(wineCust__white_scale)
```

Agora com os datasets separados e normalizados podemos entender a correlacao de todos os datasets entre deles
```{r}
matcor <- cor(wineCust_scale)
corrgram(matcor, type = "cor", lower.panel = panel.shade, upper.panel = panel.pie)

matcor <- cor(wineCust_red_scale)
corrgram(matcor, type = "cor", lower.panel = panel.shade, upper.panel = panel.pie)

matcor <- cor(wineCust__white_scale)
corrgram(matcor, type = "cor", lower.panel = panel.shade, upper.panel = panel.pie)
```
Podemos reparar que as correlacoes sao diferentes quando analisamos os tipos de vinhos separados

Agora que já entendemos a correlacao das variaveis, vamos verificar em quantos clusters podemos dividir a nossa clusterizacao

```{r}
# Vinhos juntos
hier_cluster<-hclust(dist(wineCust_scale),method='ward.D2')
d <- dist(wineCust_scale, method = "euclidean") # distance matrix
plot(hier_cluster, ylab='distancia', cex=0.6)
groups <- cutree(hier_cluster, k=5) # Divide em 5 clusters
rect.hclust(hier_cluster, k=5, border="red") 
groups <- cutree(hier_cluster, k=3) # Divide em 3 clusters
rect.hclust(hier_cluster, k=3, border="blue") 

# Vinhos vermelhos
hier_cluster<-hclust(dist(wineCust_red_scale),method='ward.D2')
d <- dist(wineCust_red_scale, method = "euclidean") # distance matrix
plot(hier_cluster, ylab='distancia', cex=0.6)
groups <- cutree(hier_cluster, k=5) # Divide em 5 clusters
rect.hclust(hier_cluster, k=5, border="red") 
groups <- cutree(hier_cluster, k=3) # Divide em 3 clusters
rect.hclust(hier_cluster, k=3, border="blue") 

#Vinhos brancos
hier_cluster<-hclust(dist(wineCust__white_scale),method='ward.D2')
d <- dist(wineCust__white_scale, method = "euclidean") # distance matrix
plot(hier_cluster, ylab='distancia', cex=0.6)
groups <- cutree(hier_cluster, k=5) # Divide em 5 clusters
rect.hclust(hier_cluster, k=5, border="red") 
groups <- cutree(hier_cluster, k=3) # Divide em 3 clusters
rect.hclust(hier_cluster, k=3, border="blue") 
```
Em todos os casos, nos pareceu mais interessante seguir com 5 clusters.

Mas para termos certeza, vamos seguir com mais um metodo, o elbow method
```{r}
# Todos os vinhos
wss <- (nrow(wineCust_scale)-1)*sum(apply(wineCust_scale,2,var))
for (i in 2:20) wss[i] <- sum(kmeans(wineCust_scale,
                                     centers=i)$withinss)
plot(1:20, wss, type="b", xlab="Numero de clusters",
     ylab="Variacao") 

# Apenas vinhos vermelhos
wss <- (nrow(wineCust_red_scale)-1)*sum(apply(wineCust_red_scale,2,var))
for (i in 2:20) wss[i] <- sum(kmeans(wineCust_red_scale,
                                     centers=i)$withinss)
plot(1:20, wss, type="b", xlab="Numero de clusters",
     ylab="Variacao") 

# Apenas vinhos brancos
wss <- (nrow(wineCust__white_scale)-1)*sum(apply(wineCust__white_scale,2,var))
for (i in 2:20) wss[i] <- sum(kmeans(wineCust__white_scale,
                                     centers=i)$withinss)
plot(1:20, wss, type="b", xlab="Numero de clusters",
     ylab="Variacao") 
```

De acordo com o Elbow method, achamos que poderia ser prudente seguirmos com numeros diferentes de clusters por dataset, mas para efeito de comparacao ficaremos com 6 clusters para todos os datasets:

```{r}
# Todos os vinhos
attach(as.data.frame(wineCust_scale))
clus_teste <- tkmeans(wineCust_scale, k = 6, alpha = 0.03)
plot(clus_teste)

# Vinhos vermelhos
attach(as.data.frame(wineCust_red_scale))
clus_teste <- tkmeans(wineCust_red_scale, k = 6, alpha = 0.03)
plot(clus_teste)

# Vinhos brancos
attach(as.data.frame(wineCust__white_scale))
clus_teste <- tkmeans(wineCust__white_scale, k = 6, alpha = 0.03)
plot(clus_teste)

```

## Com PCA

As premissas sao exatamente as mesmas da analise sem PCA, por tanto:
- Todos juntos
- Brancos
- Vermelhos

Separando os datasets em total, vermelho e white
```{r}
wineCust <- vinhos

winecust_red <- vinhosTintos
winecust_white <- vinhosBrancos
```


Rodando o PCA para encontrarmos quais componentes serao executados
```{r}
#wineCust_pr <- prcomp(scale(select (wineCust,-c(Vinho,id_vinho))))
prcomp(wineCust %>% dplyr::select(.,-c('id_vinho','Vinho','quality.cat'))) -> wineCust_pr
#winecust_red_pr <- prcomp(scale(select (winecust_red,-c(Vinho,id_vinho))))
prcomp(winecust_red %>% dplyr::select(.,-c('id_vinho','Vinho','quality.cat'))) -> winecust_red_pr
#winecust_white_pr <- prcomp(scale(select (winecust_white,-c(Vinho,id_vinho))))
prcomp(winecust_white %>% dplyr::select(.,-c('id_vinho','Vinho','quality.cat'))) -> winecust_white_pr

wineCust_scale_pr <- wineCust_pr$rotation[,1:9]
wineCust_red_scale_pr <- winecust_red_pr$rotation[,1:9]
wineCust__white_scale_pr <- winecust_white_pr$rotation[,1:9]
```


Agora com os datasets separados e normalizados podemos entender a correlacao de todos os datasets entre deles
```{r}
matcor <- cor(wineCust_scale_pr)
corrgram(matcor, type = "cor", lower.panel = panel.shade, upper.panel = panel.pie)

matcor <- cor(wineCust_red_scale_pr)
corrgram(matcor, type = "cor", lower.panel = panel.shade, upper.panel = panel.pie)

matcor <- cor(wineCust__white_scale_pr)
corrgram(matcor, type = "cor", lower.panel = panel.shade, upper.panel = panel.pie)
```
Podemos reparar que as correlacoes sao diferentes quando analisamos os tipos de vinhos separados

Agora que já entendemos a correlacao das variaveis, vamos verificar em quantos clusters podemos dividir a nossa clusterizacao

```{r}
# Vinhos juntos
hier_cluster<-hclust(dist(wineCust_scale_pr),method='ward.D2')
d <- dist(wineCust_scale_pr, method = "euclidean") # distance matrix
plot(hier_cluster, ylab='distancia', cex=0.6)
groups <- cutree(hier_cluster, k=5) # Divide em 5 clusters
rect.hclust(hier_cluster, k=5, border="red") 
groups <- cutree(hier_cluster, k=3) # Divide em 3 clusters
rect.hclust(hier_cluster, k=3, border="blue") 

# Vinhos vermelhos
hier_cluster<-hclust(dist(wineCust_red_scale_pr),method='ward.D2')
d <- dist(wineCust_red_scale_pr, method = "euclidean") # distance matrix
plot(hier_cluster, ylab='distancia', cex=0.6)
groups <- cutree(hier_cluster, k=5) # Divide em 5 clusters
rect.hclust(hier_cluster, k=5, border="red") 
groups <- cutree(hier_cluster, k=3) # Divide em 3 clusters
rect.hclust(hier_cluster, k=3, border="blue") 

#Vinhos brancos
hier_cluster<-hclust(dist(wineCust__white_scale_pr),method='ward.D2')
d <- dist(wineCust__white_scale_pr, method = "euclidean") # distance matrix
plot(hier_cluster, ylab='distancia', cex=0.6)
groups <- cutree(hier_cluster, k=5) # Divide em 5 clusters
rect.hclust(hier_cluster, k=5, border="red") 
groups <- cutree(hier_cluster, k=3) # Divide em 3 clusters
rect.hclust(hier_cluster, k=3, border="blue") 
```

Em todos os casos, nos pareceu mais interessante seguir com 5 clusters.

Mas para termos certeza, vamos seguir com mais um metodo, o elbow method

```{r}
# Todos os vinhos
wss <- (nrow(wineCust_scale_pr)-1)*sum(apply(wineCust_scale_pr,2,var))
for (i in 1:9) wss[i] <- sum(kmeans(wineCust_scale_pr,
                                     centers=i)$withinss)
plot(1:9, wss, type="b", xlab="Numero de clusters",
     ylab="Variacao") 

# Apenas vinhos vermelhos
wss <- (nrow(wineCust_red_scale_pr)-1)*sum(apply(wineCust_red_scale_pr,2,var))
for (i in 1:9) wss[i] <- sum(kmeans(wineCust_red_scale_pr,
                                     centers=i)$withinss)
plot(1:9, wss, type="b", xlab="Numero de clusters",
     ylab="Variacao") 

# Apenas vinhos brancos
wss <- (nrow(wineCust__white_scale_pr)-1)*sum(apply(wineCust__white_scale_pr,2,var))
for (i in 1:9) wss[i] <- sum(kmeans(wineCust__white_scale_pr,
                                     centers=i)$withinss)
plot(1:9, wss, type="b", xlab="Numero de clusters",
     ylab="Variacao") 
```

A variação se mostrou muito diferente utilizando PCA, mas para efeitos de comparacao continuaremos com 6 clusters:

```{r}
# Todos os vinhos
attach(as.data.frame(wineCust_scale_pr))
clus_teste <- tkmeans(wineCust_scale_pr, k = 6, alpha = 0.03)
plot(clus_teste$int$er.obj)

# Vinhos vermelhos
attach(as.data.frame(wineCust_red_scale_pr))
clus_teste <- tkmeans(wineCust_red_scale_pr, k = 6, alpha = 0.03)
plot(clus_teste$int$er.obj)

# Vinhos brancos
attach(as.data.frame(wineCust__white_scale_pr))
clus_teste <- tkmeans(wineCust__white_scale_pr, k = 6, alpha = 0.03)
plot(clus_teste$int$er.obj)

```

## Conclusões sobre a Análise e Clusters

1.	Definição das variáveis segmentadoras
    a.	Utilizamos todas as variáveis do dataset para auxiliar na cauterização dos dados. Quando utilizado PCA, utilizamos apenas componentes que garantissem até 87% da variabilidade estatística do DATASET
2.	Análise Exploratória dos dados
    a.	Como mostrado no RMD, a analise foi feita tanto com PCA quanto para sem PCA
3.	Critérios para definição da quantidade de grupos (clusters)
    a.	Os critérios utilizados foram dendograma e elbow method
4.	Resultados encontrados – Caracterização dos Clusters
    a.	6 clusters que apesar de muito bem divididos possuem uma série de intersecções 
5.	Para cada etapa anterior colocar comentários sobre a técnica utiliza e análise sobre as variáveis utilizadas e seus respectivos “achados”  
    a.	Ver o RMD
6.	Utilizando componentes principais (PCA), explique sobre a quantidade de componentes e a interpretação dos componentes.
    a.	Utilizamos componentes para garantir 87% da variabilidade do dataset. 
7.	Defina os clusters com os componentes encontrados.
    a.	Ver o RMD
8.	Quantos clusters utilizando os componentes encontrados
    a.	Optamos por continuar utilizando 6 componentes para efeitos de comparação com a analise sem PCA, uma vez que a utilização de componentes principais acaba modificando bastante os resultados da analise
9.	Resultados encontrados – Caracterização dos Clusters gerado com os componentes
    a.	Ver o RMD
10.	Cruzar os clusters obtidos a partir das variáveis e clusters obtidos pelos componentes principais. O que aconteceu?
    a.	Encontramos uma grande intersecção de vinhos, mas existem vinhos diferentes em clusters diferentes.
    b.	Acreditamos que isso possa decorrer de dois pontos
        i.	Como garantimos apenas 87% da variabilidade estatística, podemos acabar classificando vinhos de formas diferentes
        ii.	O PCA tende pode acabar encontrando centros diferentes para os centroides, e isso pode acabar encontrando clusters diferentes

